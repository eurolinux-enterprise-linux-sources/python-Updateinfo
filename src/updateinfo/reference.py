'''
    For an update you can supply an external website that details
    the reason more clearly that you can here.
'''
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Version 0.1 by Pat Riehecky <riehecky@fnal.gov> for Scientific Linux

# we work with either, but better with lxml
try:
    import lxml
    from lxml import etree as xmletree
except ImportError:
    import xml.etree.ElementTree as xmletree

class Reference:
    '''
        This object helps you define a reference for the update

        The various set_* methods should help you configure this.
    '''
    def __init__(self, reftype=None, href=None, refid=None, title=None):
        '''
            You can pass all the required values in right here at
            the constructor if you want

            Relevant metainfo vars:
             self.reftype
             self.refid
             self.href
             self.title
        '''
        self.reftype = None
        self.refid = None
        self.href = None
        self.title = None

        self.set_type(reftype)
        self.set_title(title)
        self.set_id(refid)
        self.set_href(href)

    def __str__(self):
        '''
            Simple way of dumping the xml
        '''
        return self.return_xml(header=False, pretty=True)

    def check_values(self):
        '''
            Make sure we've got everything we need set.
            May throw ValueError if you've got some bad data... heads up
            Nothing calls this, but this function should help you
             see what you need.  It may be out of sync with the xsd so beware.
        '''
        # we do sorta need these for anything to make sense
        if self.href == None or self.reftype == None:
            return False

        # id isn't required so don't abuse that right!
        # title isn't required so don't abuse that right!

        if self.reftype not in ['bugzilla', 'cve', 'fate', 'commit',
                                'trac', 'other']:
            raise ValueError("""Reference type not 'fate', 'trac', 'commit',
                                ,'other', 'bugzilla' or 'cve'""")

        return True

    def set_href(self, href):
        '''
            URL for the reference
        '''
        self.href = href

    def set_id(self, refid):
        '''
            ID for the reference at the URL
        '''
        self.refid = refid

    def set_title(self, title):
        '''
            Title for the reference
            Keep it under 65 chars
        '''
        if title != None:
            if isinstance(title, str):
                self.title = unicode(title, encoding='utf-8')
            elif isinstance(title, unicode):
                self.title = title
            else:
                raise TypeError("Wrong type " + title +
                                " type " + type(title))
        else:
            self.title = None

    def set_type(self, reftype):
        '''
            What type of reference?
        '''
        if reftype != None:
            self.reftype = reftype.lower()
        else:
            self.reftype = None

    def return_xml(self, header=True, pretty=False):
        '''
            returns the xml generated by this object
        '''
        if header:
            xml_header = '<?xml version="1.0" encoding="UTF-8"?>\n'
        else:
            xml_header = ''
        xml_string = xml_header + xmletree.tostring(self.to_xml_obj())

        if pretty:
            # since we don't have to require lxml, we are doing this
            # with the 'native' dom objects.  It is a bit ugly
            # but should be pure python and therefore portable.
            from xml.dom import minidom
            from xml.dom.ext import PrettyPrint
            from StringIO import StringIO
            dom_string = minidom.parseString(xml_string)
            tmpstream = StringIO()
            PrettyPrint(dom_string, stream=tmpstream, encoding='UTF-8')
            xml_string = tmpstream.getvalue()
            tmpstream.close()

        return xml_string

    def to_xml_obj(self):
        '''
            returns an xml.etree.ElementTree.Element object of the package
        '''
        xmlobj = xmletree.Element('reference')
        if self.title != None:
            xmlobj.attrib['title'] = self.title
        xmlobj.attrib['type'] = self.reftype
        if self.refid != None:
            xmlobj.attrib['id'] = self.refid
        xmlobj.attrib['href'] = self.href

        return xmlobj

    def from_xml_obj(self, xmlobj):
        '''
            Pass in the xml object from a previous run and it will set the
            values in this object for you.
        '''
        # lxml comment lines are of this type
        if xmletree.__package__ == 'lxml':
            if isinstance(xmlobj, lxml.etree._Comment):
                return False

        # it seems xml.etree.ElementTree doesn't
        #  do anything with the comment lines, so
        #  I don't need to hunt for them here

        if xmlobj.attrib.has_key('title'):
            self.title = xmlobj.attrib['title']
        elif xmlobj.text != None:
            self.title = xmlobj.text

        if xmlobj.attrib.has_key('type'):
            self.reftype = xmlobj.attrib['type']

        if xmlobj.attrib.has_key('id'):
            self.refid = xmlobj.attrib['id']

        if xmlobj.attrib.has_key('href'):
            self.href = xmlobj.attrib['href']

        return True
